// Astal
import GObject, { register, property } from 'astal/gobject';
import {
  monitorFile,
  readFileAsync,
  readFile,
  writeFileAsync,
  writeFile,
} from 'astal/file';
import { App } from 'astal/gtk3';
import { exec } from 'astal/process';

// Config
import { HOME, STATE, configPath } from '../../../config/user_config';
const APPS = JSON.parse(readFile(`${configPath}/apps.json`));
const OPTIONS = `${STATE}/config/appearance/appearance.json`;

function getFromOptions(key: string) {
  return JSON.parse(readFile(OPTIONS))[key];
}

@register({ GTypeName: 'Config.Appearance' })
export default class Appearance extends GObject.Object {
  static instance: Appearance;
  static get_default() {
    if (!this.instance) this.instance = new Appearance();
    return this.instance;
  }

  updateOption(key: string, value: any) {
    let _options = JSON.parse(readFile(OPTIONS));
    _options[key] = value;

    writeFile(OPTIONS, JSON.stringify(_options));
  }

  syncAppearance() {
    // Apply Styles
    writeFile(
      `${HOME}/.config/ags/style/astal.scss`,
      `
        // This file is automatically generated by Astal.
        // If you want to change the colors, do so in ~/.config/ags/config/styles.json
        // Run "ags quit" then "ags run" to apply new colors.
    
        $transparency: ${this.#transparency};
        $bg: rgb(${this.#bg});
        $bg_trans: rgba($bg, $transparency);
        $surfaceDark: rgb(${this.#surface_dark});
        $surfaceDark_trans: rgba($surfaceDark, $transparency);
        $surface: rgb(${this.#surface});
        $surface_trans: rgba($surface, $transparency);
        $fg: rgb(${this.#fg});
        $fg_trans: rgba($fg, $transparency);
        $hover: rgb(${this.#hover});
        $hover_trans: rgba($hover, $transparency);
        $text: rgb(${this.#text});
        $error: rgb(${this.#error});
    
        $paddingBase: ${this.#paddingBase}px;
        $borderWidth: ${this.#borderWidth}px;
        $brv: ${this.#cornerRounding}px;
        $buttonSize: ${this.#buttonSize}px;
        `
    );

    // Apply Hyprland
    writeFile(
      `${HOME}/.config/hypr/hyprland/astal.conf`,
      `
      # This file is automatically generated by Astal.
      # If you want to change the colors, do so in ~/.config/ags/config/styles.json
      # Run "ags quit" then "ags run" to apply new colors.
  
      general {
        col.active_border = rgb(${this.#surface})
        col.inactive_border = rgb(${this.#bg})
  
        gaps_in = ${this.#paddingBase / 2}
        gaps_out = ${this.#paddingBase}
        gaps_workspaces = 50
        border_size = ${this.#borderWidth}
      }
  
      decoration {
        rounding = ${this.#cornerRounding / 2}
  
        shadow {
          color = rgba(${this.#bg},0.5)
        }
      }
  
      plugin {
        overview {
          panelColor = rgba(${this.#bg},${this.#transparency})
          panelBorderColor = rgb(${this.#bg})
          workspaceActiveBorder = rgb(${this.#surface})
          workspaceInactiveBorder = rgb(${this.#bg})
        }
      }
  
      $terminal = ${APPS.terminal}
      $terminalAlt = ${APPS.terminalAlt}
      $webBrowser = ${APPS.webBrowser}
      $webBrowserAlt = ${APPS.webBrowserAlt}
      $fileManager = ${APPS.fileManager}
      $fileManagerAlt = ${APPS.fileManagerAlt}
      $textEditor = ${APPS.textEditor}
      $codeEditor = ${APPS.codeEditor}
      $settings = ${APPS.settings}
      $systemMonitor = ${APPS.systemMonitor}
      $volumeMixer = ${APPS.audioSettings}
      `
    );

    // Apply Kitty
    let kittyConf = readFile(`${HOME}/.config/kitty/kitty.conf`);
    kittyConf = kittyConf.slice(0, kittyConf.indexOf('# ASTAL') - 1);

    function convertToHex(input: any) {
      return input
        .split(',')
        .map((v: any) => {
          let int = parseInt(v);
          if (int < 16) return `0${int.toString(16)}`;
          return int.toString(16);
        })
        .join('');
    }

    kittyConf = `${kittyConf}
# ASTAL
foreground #${convertToHex(this.#text)}
background #${convertToHex(this.#bg)}

background_opacity ${this.#transparency}`;

    writeFile(`${HOME}/.config/kitty/kitty.conf`, kittyConf);

    exec(['sass', './style.scss', '/tmp/style.css']);
    App.apply_css('/tmp/style.css');
  }

  #transparency = getFromOptions('transparency');
  #bg = getFromOptions('bg');
  #surface_dark = getFromOptions('surface_dark');
  #surface = getFromOptions('surface');
  #fg = getFromOptions('fg');
  #hover = getFromOptions('hover');
  #text = getFromOptions('text');
  #error = getFromOptions('error');
  #borderWidth = getFromOptions('borderWidth');
  #cornerRounding = getFromOptions('cornerRounding');
  #paddingBase = getFromOptions('paddingBase');
  #buttonSize = getFromOptions('buttonSize');

  @property(Number)
  get transparency() {
    return this.#transparency;
  }
  set transparency(value) {
    this.updateOption('transparency', value);
  }

  @property(String)
  get bg() {
    return this.#bg;
  }
  set bg(value) {
    this.updateOption('bg', value);
  }

  @property(String)
  get surface_dark() {
    return this.#surface_dark;
  }
  set surface_dark(value) {
    this.updateOption('surface_dark', value);
  }

  @property(String)
  get surface() {
    return this.#surface;
  }
  set surface(value) {
    this.updateOption('surface', value);
  }

  @property(String)
  get fg() {
    return this.#fg;
  }
  set fg(value) {
    this.updateOption('fg', value);
  }

  @property(String)
  get hover() {
    return this.#hover;
  }
  set hover(value) {
    this.updateOption('hover', value);
  }

  @property(String)
  get text() {
    return this.#text;
  }
  set text(value) {
    this.updateOption('text', value);
  }

  @property(String)
  get error() {
    return this.#error;
  }
  set error(value) {
    this.updateOption('error', value);
  }

  @property(Number)
  get borderWidth() {
    return this.#borderWidth;
  }
  set borderWidth(value) {
    this.updateOption('borderWidth', value);
  }

  @property(Number)
  get cornerRounding() {
    return this.#cornerRounding;
  }
  set cornerRounding(value) {
    this.updateOption('cornerRounding', value);
  }

  @property(Number)
  get paddingBase() {
    return this.#paddingBase;
  }
  set paddingBase(value) {
    this.updateOption('paddingBase', value);
  }

  @property(Number)
  get buttonSize() {
    return this.#buttonSize;
  }
  set buttonSize(value) {
    this.updateOption('buttonSize', value);
  }

  constructor() {
    super();

    monitorFile(OPTIONS, async (f) => {
      const v = await readFileAsync(f).then((value) => JSON.parse(value));
      if (v.transparency !== this.#transparency) {
        this.#transparency = Number(v.transparency);
        this.notify('transparency');
      }
      if (v.bg !== this.#bg) {
        this.#bg = String(v.bg);
        this.notify('bg');
      }
      if (v.surface_dark !== this.#surface_dark) {
        this.#surface_dark = String(v.surface_dark);
        this.notify('surface_dark');
      }
      if (v.surface !== this.#surface) {
        this.#surface = String(v.surface);
        this.notify('surface');
      }
      if (v.fg !== this.#fg) {
        this.#fg = String(v.fg);
        this.notify('fg');
      }
      if (v.hover !== this.#hover) {
        this.#hover = String(v.hover);
        this.notify('hover');
      }
      if (v.text !== this.#text) {
        this.#text = String(v.text);
        this.notify('text');
      }
      if (v.error !== this.#error) {
        this.#error = String(v.error);
        this.notify('error');
      }
      if (v.borderWidth !== this.#borderWidth) {
        this.#borderWidth = Number(v.borderWidth);
        this.notify('borderWidth');
      }
      if (v.cornerRounding !== this.#cornerRounding) {
        this.#cornerRounding = Number(v.cornerRounding);
        this.notify('cornerRounding');
      }
      if (v.paddingBase !== this.#paddingBase) {
        this.#paddingBase = Number(v.paddingBase);
        this.notify('paddingBase');
      }
      if (v.buttonSize !== this.#buttonSize) {
        this.#buttonSize = Number(v.buttonSize);
        this.notify('buttonSize');
      }
      this.syncAppearance();
    });
  }
}
